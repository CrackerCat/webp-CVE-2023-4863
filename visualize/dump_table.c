#include <stdio.h>
//#include "src/utils/huffman_utils.c"
#include "src/utils/bit_reader_utils.c"
#include "huffman_utils.c"


/* -------------------------------------------------- */
// code taken from libwebp 

uint32_t VP8LReadBits2(VP8LBitReader* const br, int n_bits) {
  if(n_bits >= 0);
  // Flag an error if end_of_stream or n_bits is more than allowed limit.

  if (!br->eos_ && n_bits <= VP8L_MAX_NUM_BIT_READ) {

    const uint32_t val = VP8LPrefetchBits(br) & kBitMask[n_bits];
    printf("val: %d\n", val);
    const int new_bits = br->bit_pos_ + n_bits;
    br->bit_pos_ = new_bits;
    ShiftBytes(br);
    return val;
  } else {
    VP8LSetEndOfStream(br);
    return 0;
  }
}

// vp8l_dec.c
#define NUM_CODE_LENGTH_CODES       19
static const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {
  17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};
static const int kCodeLengthLiterals = 16;
static const int kCodeLengthRepeatCode = 16;
static const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };
static const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };


/* -------------------------------------------------- */



#define SYM 16
// 410
#define TABLE_SIZE 0xfff
#define SYMS 40


int main(int argc, char **argv) {
    int count[MAX_ALLOWED_CODE_LENGTH+1];
     // fill count from argv[]
    if(argc != MAX_ALLOWED_CODE_LENGTH) {
        printf("invalid count[]\n");
        return 0;
    }
    //printf("[");
    for (int i = 1; i < argc; i++) {
        count[i-1] = atoi(argv[i]);
        //printf("%d, ", count[i-1]);
    }
    //printf("]\n");


            
    const HuffmanCode table[TABLE_SIZE];
    memset(table, 0, sizeof(table));

    // count to code_lengths2
    int code_lengths[SYMS] = { 0 };
    int len = 0;
    for (int i = 0; i <= MAX_ALLOWED_CODE_LENGTH; ++i) {
        for (int j = 0; j < count[i]; ++j) {
            code_lengths[len++] = i;
        }
    }


    int result = VP8LBuildHuffmanTable(table, 8, code_lengths, SYMS);
    
    if(result == 0) {
        printf("fail\n");
    }
    printf("%d\n", result);

    // write the `table` array to a bmp
    FILE *f = fopen("table", "wb");
    
    if (f == NULL) {
        printf("Error opening file!\n");
    }

    // dump table print
    /*
    for (int i = 0; i < TABLE_SIZE; i++) {
        if(table[i].bits != 0 || table[i].value != 0)
            printf("table[%d] = { %d, %d }\n", i, table[i].bits, table[i].value);
    }
    */
    fwrite(table, sizeof(HuffmanCode), TABLE_SIZE, f);
    fclose(f);
}