#include <stdint.h>
#include <stdio.h>
#include <stdint.h>
#include <assert.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include "src/utils/bit_reader_utils.c"
#include "src/utils/utils.c"

void* WebPSafeMalloc(uint64_t nmemb, size_t size);

#include "huffman_utils.c"

/*

[0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0] =  248 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0] =  382 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 3, 0, 0, 0, 0, 0, 0] =  384 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 5, 0, 0, 0, 0, 0, 0] =  386 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 7, 0, 0, 0, 0, 0, 0] =  388 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 11, 0, 0, 0, 0, 0, 0] =  392 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 0, 0, 0, 0, 0, 0] =  394 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 0, 0, 0, 0, 0, 0] =  398 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 0, 0, 0, 0, 0, 0] =  400 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 0, 0, 0, 0, 0, 0] =  404 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 3, 0, 0, 0, 0, 0] =  406 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 5, 0, 0, 0, 0, 0] =  408 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 7, 0, 0, 0, 0, 0] =  410 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 11, 0, 0, 0, 0, 0] =  414 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 13, 0, 0, 0, 0, 0] =  416 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 5, 1, 5, 0, 0, 0] =  418 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 13, 1, 5, 0, 0, 0] =  420 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 5, 1, 7, 0, 0, 0] =  422 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 5, 1, 1, 5, 0, 0] =  426 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 1, 1, 1, 7, 0, 0] =  430 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 13, 1, 1, 7, 0, 0] =  432 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 1, 1, 1, 1, 5, 0] =  434 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 1, 1, 1, 1, 5, 0] =  438 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 5, 1, 1, 1, 5, 0] =  442 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 1, 1, 1, 1, 7, 0] =  444 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 1, 1, 1, 1, 7, 0] =  448 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 1, 1, 1, 1, 7, 0] =  450 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 1, 1, 1, 1, 7, 0] =  454 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 13, 1, 1, 1, 7, 0] =  456 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 1, 1, 1, 1, 11, 0] =  458 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 5, 1, 1, 1, 11, 0] =  460 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 1, 1, 1, 1, 1, 5] =  464 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 1, 1, 1, 1, 1, 5] =  466 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 1, 1, 1, 1, 1, 5] =  470 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 13, 1, 1, 1, 1, 5] =  472 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 7] =  480 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 3, 1, 1, 1, 1, 1, 7] =  482 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 5, 1, 1, 1, 1, 1, 7] =  484 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 7, 1, 1, 1, 1, 1, 7] =  486 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 11, 1, 1, 1, 1, 1, 7] =  490 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 1, 1, 1, 1, 1, 7] =  492 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 1, 1, 1, 1, 1, 7] =  496 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 1, 1, 1, 1, 1, 7] =  498 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 23, 1, 1, 1, 1, 1, 7] =  502 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 11, 1, 1, 1, 1, 1, 11] =  506 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 13, 1, 1, 1, 1, 1, 11] =  508 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 17, 1, 1, 1, 1, 1, 11] =  512 
[0, 0, 0, 1, 0, 0, 0, 1, 1, 19, 1, 1, 1, 1, 1, 11] =  514

*/

/*

    Idea: the root table is 8bit. so we define code_lengths to fill this root table with only 2 symbols.
    Then we bruteforce the remaining symbols to find the largest 2nd table size.

    see: https://stackoverflow.com/questions/13804629/huffman-code-with-lookup-table

    hardcoded root_table: 
            [0, 1, 0, 0, 0, 0, 0, 0, 1] 

    count = [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]

    * count[0] is always 0 (there exists no symbol of bit length 0)
    * count[1] we have one symbol of bit length 1
    * count[2-7] set to 0
    * count[8] we have one symbol of bit length 8

    I believe the resulting table looks something like this:

    Index    Index(binary)    Symbol  Bits required
    0        00000000         a       1
    1        00000001         a       1
    2        00000010         a       1
    3        00000011         a       1
    4        00000100         a       1
    ...
    252      11111100         a       1
    253      11111101         a       1
    254      11111110         b       8
    255      11111111      *pointer to 2nd level table

    all other symbols will then end up in the 2nd level and we bruteforce that size


    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0] =  256
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1] =  384
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 12, 1] =  448
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 27, 9, 3] =  512
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 28, 7, 1, 3] =  528
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 13, 21, 1, 1, 3] =  536
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 6, 11, 17, 1, 1, 3] =  540
    [0, 1, 0, 0, 0, 0, 0, 0, 1, 3, 5, 9, 17, 1, 1, 3] =  542


    UPDATE: actually it seems like we don't even need that. Keep root_table 0, and just bruteforce the 2nd level table
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 9, 17, 1, 1, 3] =  542

    [0, 0, 0, 0, 0, 0, 0, 0, 0] hardcoded root_table
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] =  384
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 12, 1] =  448
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 9, 3] =  512
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 7, 1, 3] =  528
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 21, 1, 1, 3] =  536
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 11, 17, 1, 1, 3] =  540
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 9, 17, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 25, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 13, 1, 17, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 13, 17, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 21, 9, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 29, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 9, 17, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 25, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 1, 17, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 17, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 17, 9, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 25, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 5, 1, 17, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 5, 17, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 13, 9, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 21, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 1, 1, 17, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 1, 17, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 9, 9, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 17, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 5, 9, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 13, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 1, 9, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 9, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 5, 1, 1, 1, 1, 3] =  542
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 1, 1, 1, 1, 1, 3] =  542

*/

/*
webp:
./enough 256 8 15
gcc -DSYM=256 -DHUFFMAN_TABLE_BITS=8 -DMAX_ALLOWED_CODE_LENGTH=15  -DPRIMES=1 brutePrime.c -o brutePrime && ./brutePrime
[0, 0, 0, 0, 1, 1, 1, 0, 1, 241, 0, 0, 0, 0, 0, 0] =  624
[0, 0, 0, 0, 1, 1, 1, 0, 1, 251, 0, 0, 0, 0, 0, 0] =  634
[...]
[0, 0, 0, 0, 1, 1, 1, 0, 1, 239, 5, 1, 1, 1, 3, 0] =  690

webp:
gcc -DSYM=40 -DHUFFMAN_TABLE_BITS=8 -DMAX_ALLOWED_CODE_LENGTH=15  -DPRIMES=1 brutePrime.c -o brutePrime && ./brutePrime
[0, 0, 0, 0, 1, 0, 1, 1, 0, 23, 0, 0, 0, 0, 0, 0] =  406
[0, 0, 0, 0, 1, 0, 1, 1, 0, 29, 0, 0, 0, 0, 0, 0] =  412
[...]
[0, 0, 1, 0, 1, 0, 0, 0, 0, 29, 1, 1, 1, 1, 1, 3] =  540
*/

/*
jpegli (kJpegHuffmanLutSize = 758):
gcc -DSYM=256 -DHUFFMAN_TABLE_BITS=8 -DMAX_ALLOWED_CODE_LENGTH=16 -DPRIMES=1 brutePrime.c -o brutePrime && ./brutePrime
[0, 0, 1, 0, 0, 1, 1, 1, 1, 241, 3, 0, 0, 0, 0, 0, 0] =  756
[0, 0, 1, 0, 0, 1, 1, 1, 1, 239, 7, 0, 0, 0, 0, 0, 0] =  758
[0, 0, 1, 0, 0, 1, 1, 1, 1, 241, 7, 0, 0, 0, 0, 0, 0] =  760
[...]
[0, 0, 1, 0, 0, 1, 1, 1, 1, 239, 5, 1, 1, 1, 3, 0, 0] =  818

*/

/*
brotli
gcc -DSYM=704 -DHUFFMAN_TABLE_BITS=8 -DMAX_ALLOWED_CODE_LENGTH=15  -DPRIMES=1 brutePrime.c -o brutePrime && ./brutePrime
*/

// "enough 286 9 15" -> 852
// [0, 1, 1, 0, 1, 0, 2, 2, 2, 1, 53, 113, 89, 17, 1, 2] =  844
// [0, 1, 1, 1, 0, 0, 2, 2, 0, 0, 7, 73, 97, 97, 1, 2] =  846
// [0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 37, 109, 113, 17, 1, 2] =  848
// [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 67, 73, 41, 1, 97, 2] =  850
// [0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 67, 17, 97, 97, 1, 2] =  850
// "enough 30 6 15" ->  592
// [0, 1, 1, 1, 0, 0, 0, 13, 5, 1, 1, 1, 1, 1, 1, 2] =  592
// [0, 1, 1, 1, 0, 0, 0, 13, 5, 1, 1, 1, 1, 1, 1, 2] =  592
// [0, 1, 1, 1, 0, 0, 0, 13, 5, 1, 1, 1, 1, 1, 1, 2] =  592
// [0, 1, 1, 1, 0, 0, 0, 13, 5, 1, 1, 1, 1, 1, 1, 2] =  592
// [0, 1, 1, 1, 0, 0, 0, 13, 5, 1, 1, 1, 1, 1, 1, 2] =  592
#ifndef SYM
    #define SYM 40
#endif

#ifndef HUFFMAN_TABLE_BITS
    #define HUFFMAN_TABLE_BITS 8
#endif

#ifndef MAX_ALLOWED_CODE_LENGTH
    #define MAX_ALLOWED_CODE_LENGTH 15
#endif

int main(int argc, char** argv) {

    // seed
    srand(time(NULL));
    
    int brute[MAX_ALLOWED_CODE_LENGTH+1] = {0};
    int count[MAX_ALLOWED_CODE_LENGTH+1];
    int largest_count[MAX_ALLOWED_CODE_LENGTH+1] = {0};
    int largest_size = 0;

    #ifdef PRIMES
        printf("using primes\n");
    #else
        printf("using brute\n");
    #endif

    // fuzz loop
    while(1) {
        /* ---- STEP 1 ----
        * set the root_table
        */
        
        memset(brute, 0, sizeof(brute));
        
        // always zero. there exists no symbol of bit length 0
        brute[0] = 0;
        #if 0
            brute[1] = rand() % 2;
            brute[2] = rand() % 4;
            brute[3] = rand() % 8;
            brute[4] = rand() % 16;
            brute[5] = rand() % 32;
            brute[6] = rand() % 64;
            brute[7] = rand() % 4;
            brute[8] = rand() % 4;
            brute[9] = rand() % 4;
        #else
            brute[1] = rand() % 2;
            brute[2] = rand() % 2;
            brute[3] = rand() % 2;
            brute[4] = rand() % 2;
            brute[5] = rand() % 2;
            brute[6] = rand() % 2;
            brute[7] = rand() % 2;
            brute[8] = rand() % 2;
            brute[9] = rand() % 2;
        #endif
        memset(brute, 0, sizeof(brute));

        int root_bits = HUFFMAN_TABLE_BITS;
        
        #if 0
        printf("[0");
        for (int i = 1; i <= root_bits; i++) {
                printf(", %d", brute[i]);
        }
        printf("] hardcoded root_table\n");
        #endif


        int used_syms = 0;
        for (int i = 1; i <= root_bits; i++) {
                used_syms += brute[i];
        }

        int syms_left = SYM - used_syms;

        /* ---- STEP 2 ----
        *  exhaustive bruteforce of the last count[9-15] entries
        */
        int primes[] = {0, 1, 2, 3, 5, 7, 11, 13, 17, 19, 23};
        

        int nPrimes = sizeof(primes)/sizeof(primes[0]);
        int i,j,k,l,m,n,o,p,q,r,s,t = 0;
        
        for(i = 0; i<nPrimes && primes[i] < syms_left; i++) 
        for(j = 0; j<nPrimes && primes[j] < syms_left - primes[i]; j++)
        for(k = 0; k<nPrimes && primes[k] < syms_left - primes[i] - primes[j]; k++)
        for(l = 0; l<nPrimes && primes[l] < syms_left - primes[i] - primes[j] - primes[k]; l++)
        for(m = 0; m<nPrimes && primes[m] < syms_left - primes[i] - primes[j] - primes[k] - primes[l]; m++)
        for(n = 0; n<nPrimes && primes[n] < syms_left - primes[i] - primes[j] - primes[k] - primes[l] - primes[m]; n++)
        for(o = 0; o<nPrimes && primes[o] < syms_left - primes[i] - primes[j] - primes[k] - primes[l] - primes[m] - primes[n]; o++)
        for(p = 0; p<nPrimes && primes[p] < syms_left - primes[i] - primes[j] - primes[k] - primes[l] - primes[m] - primes[n] - primes[o]; p++)
        {

        brute[ 9] = primes[p];
        brute[10] = primes[o];
        brute[11] = primes[n];
        brute[12] = primes[m];
        brute[13] = primes[l];
        brute[14] = primes[k];
        brute[15] = primes[j];
        brute[16] = primes[i];
        
        

        memcpy(count, brute, sizeof(count));
     
        #if 0
        /* check for an over-subscribed or incomplete set of lengths */
        int left = 1;
        for (int len = 1; len <= 15; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                //printf("oversubscribed\n");
                continue;        /* over-subscribed */
            }
        }
        int max;
        for (max = 15; max >= 1; max--)
            if (count[max] != 0) break;

        
        #if 0
        printf("[0");
        for (int i = 1; i <= MAX_ALLOWED_CODE_LENGTH; i++) {
                printf(", %d", brute[i]);
        }
        printf("] = %d\n", max);
        #endif

        if (left > 0 && max != 1) {
            //if(left < 300) printf("left = %d\n", left);
            continue;     /* incomplete set */ 
        }
        #endif

        #if 0
        printf("[0");
        for (int i = 1; i <= MAX_ALLOWED_CODE_LENGTH; i++) {
                printf(", %d", brute[i]);
        }
        printf("]\n");
        #endif

        /* ---- STEP 3 ----
        * code taken from libwebp to calculate the table size
        */
        HuffmanCode _root_table[0xffff]; // make a pseudo table large enough. we don't want overflow to find the largest size
        memset(_root_table, 0, sizeof(_root_table));

        int root_bits = HUFFMAN_TABLE_BITS;
        int total_size = 1 << root_bits;
        int step;              // step size to replicate values in current table
        uint32_t low = 0xffffffffu;        // low bits for current root entry
        uint32_t mask = total_size - 1;    // mask for low bits
        uint32_t key = 0;      // reversed prefix code
        int num_nodes = 1;     // number of Huffman tree nodes
        int num_open = 1;      // number of open branches in current tree level
        int table_bits = root_bits;        // key length of current table
        int table_size = 1 << table_bits;  // size of current table

        uint16_t _sorted[0xffff];
        HuffmanCode *root_table = _root_table;
        HuffmanCode* table = root_table;
        uint16_t *sorted = _sorted;

        int table_ptr = 0;
        int ok = 1;
        //int count[MAX_ALLOWED_CODE_LENGTH + 1] = { 0 };
        int len;

        // count to code_lengths
        int code_lengths[SYM] = { 0 };
        memset(code_lengths, 0, sizeof(code_lengths));
        len = 0;
        for (int i = 0; i <= MAX_ALLOWED_CODE_LENGTH; ++i) {
            for (int j = 0; j < count[i]; ++j) {
                code_lengths[len++] = i;
            }
        }
        total_size = VP8LBuildHuffmanTable(table, 8, code_lengths, SYM);

        // get index of last non-null value in table
        int last = 0;
        for (int i = 0; i < 0xffff; i++) {
            if(table[i].bits != 0 || table[i].value != 0) {
                last = i;
            }
        }
        
        // print new largest count[]
        if(last > largest_size ) {
            // sum
            int sum = 0;
            for (int i = 1; i <= MAX_ALLOWED_CODE_LENGTH; i++) {
                sum += brute[i];
            }
            if(sum == 0) continue;

            largest_size = last;
            memcpy(largest_count, brute, sizeof(count));

            printf("[0");
            for (int i = 1; i <= MAX_ALLOWED_CODE_LENGTH; i++) {
                    printf(", %d", brute[i]);
            }
            printf("] = ");
            printf(" %d \n", last);
            
        }
    }
    }
}