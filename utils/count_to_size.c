#include <stdint.h>
#include <stdio.h>
#include <stdint.h>
#include <assert.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>

// given a list from a count array, calculates the huffman table size
// gcc count_to_size.c -o count_to_size
// ./count_to_size 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 33, 3
// [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 33, 3] = 480

#define MAX_ALLOWED_CODE_LENGTH      15
#define HUFFMAN_TABLE_BITS 8

int NextTableBitSize(const int* const count,
                                        int len, int root_bits) {
  int left = 1 << (len - root_bits);
  while (len < MAX_ALLOWED_CODE_LENGTH) {
    left -= count[len];
    if (left <= 0) break;
    ++len;
    left <<= 1;
  }
  return len - root_bits;
}

uint32_t GetNextKey(uint32_t key, int len) {
  uint32_t step = 1 << (len - 1);
  while (key & step) {
    step >>= 1;
  }
  return step ? (key & (step - 1)) + step : key;
}

// Huffman lookup table entry
typedef struct {
    uint8_t bits;     // number of bits used for this symbol
    uint16_t value;   // symbol value or table offset
} HuffmanCode;


int ReplicateValue(HuffmanCode* table, int step, int end, HuffmanCode code) {
  if(end % step != 0) return 1;
  do {
    end -= step;
    table[end] = code;
  } while (end > 0);
  return 0;
}

#define SYM 256
#define SAMPLE 100000000

int main(int argc, char** argv) {    
    int count[MAX_ALLOWED_CODE_LENGTH+1];

    // fill count from argv[]
    if(argc <= MAX_ALLOWED_CODE_LENGTH) {
        printf("Usage: %s <count1> <count2> ... <count%d>\n", argv[0], MAX_ALLOWED_CODE_LENGTH);
        return 1;
    }
    for (int i = 1; i < argc; i++) {
        count[i-1] = atoi(argv[i]);
    }

    printf("[0");
    for (int i = 1; i < 15; i++) {
            printf(", %d", count[i]);
    }
    printf("] = ");

    int largest_count[MAX_ALLOWED_CODE_LENGTH+1] = {0};
    int largest_size = 0;
    int iters = 0;
    struct timespec start, end;
    uint64_t delta_s;
    clock_gettime(CLOCK_MONOTONIC_RAW, &start);

    memcpy(count, count, sizeof(count));
    
    int root_bits = HUFFMAN_TABLE_BITS;
    int total_size = 1 << root_bits;
    int step;              // step size to replicate values in current table
    uint32_t low = 0xffffffffu;        // low bits for current root entry
    uint32_t mask = total_size - 1;    // mask for low bits
    uint32_t key = 0;      // reversed prefix code
    int num_nodes = 1;     // number of Huffman tree nodes
    int num_open = 1;      // number of open branches in current tree level
    int table_bits = root_bits;        // key length of current table
    int table_size = 1 << table_bits;  // size of current table
    HuffmanCode _root_table[0xffff];
    uint16_t _sorted[0xffff];
    HuffmanCode *root_table = _root_table;
    HuffmanCode* table = root_table;
    uint16_t *sorted = _sorted;

    int table_ptr = 0;
    int ok = 1;
    //int count[MAX_ALLOWED_CODE_LENGTH + 1] = { 0 };

    int symbol = 0;
    // Fill in root table.
    for (int len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
        num_open <<= 1;
        num_nodes += num_open;
        num_open -= count[len];
        //printf("  count[%d]: %d\n", len, count[len]);
        //printf(", %d", count[len]);
        if (num_open < 0) {
            ok=0; break;
        }
        if (root_table == NULL) continue;
        for (; count[len] > 0; --count[len]) {
            
            HuffmanCode code;
            code.bits = (uint8_t)len;
            code.value = (uint16_t)sorted[symbol++];
            if(ReplicateValue(&table[key], step, table_size, code)) { 
                printf("fail");
                return 0;
            }
            
            key = GetNextKey(key, len);
        }
    }
    if(!ok) { 
        printf("fail");
        return 0;
    }

    int write_ptr = 0;

    // Fill in 2nd level tables and add pointers to root table.
    for (int len = root_bits + 1, step = 2; len <= MAX_ALLOWED_CODE_LENGTH;
        ++len, step <<= 1) {
        num_open <<= 1;
        num_nodes += num_open;
        //printf("  count[%d]\n", len);
        num_open -= count[len];
        //printf("  count[%d]: %d\n", len, count[len]);
        //printf(", %d", count[len]);
        if (num_open < 0) {
            ok=0; break;
        }
        //if (root_table == NULL) continue;
        for (; count[len] > 0; --count[len]) {
            HuffmanCode code;
            //printf("[&] %x & %x | %x != %x \n", key, mask, key & mask, low);
            if ((key & mask) != low) {
                table_ptr += table_size;
                table_bits = NextTableBitSize(count, len, root_bits);
                table_size = 1 << table_bits;
                //printf("[LiveOverflow] %lu += %lu\n", total_size, table_size);
                total_size += table_size;
                low = key & mask;
                root_table[low].bits = (uint8_t)(table_bits + root_bits);
                root_table[low].value = (uint16_t)((table - root_table) - low);
            }
            code.bits = (uint8_t)(len - root_bits);
            code.value = (uint16_t)sorted[symbol++];
            if(ReplicateValue(&table[key >> root_bits], step, table_size, code)) ok=0;
            
            //write_ptr = table_ptr + (key >> root_bits)+table_size;
            key = GetNextKey(key, len);
        }
    }
    
    printf("%d\n", total_size);

}